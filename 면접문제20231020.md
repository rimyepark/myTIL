# 면접 반성

 면접에서 나온 질문들을 정리하며 반성하자. 기초부터 더욱 철저하게 공부하자.

 ## javascript와 node.js

1. 정의:

- 자바스크립트 (JavaScript): 웹 브라우저에서 실행되는 스크립트 언어로, 웹 페이지의 동적 기능을 구현하기 위해 주로 사용된다. ECMAScript(ES) 기반으로 발전하고 있다.

- Node.js: Chrome V8 JavaScript 엔진 위에 구축된 JavaScript 런타임으로, 서버 사이드 애플리케이션을 개발하기 위해 사용된다.

2. 실행 환경:

- 자바스크립트: 웹 브라우저 내에서 실행된다.
- Node.js: 서버나 컴퓨터의 OS 환경에서 실행된다.

3. API와 라이브러리:

- 자바스크립트: DOM(Document Object Model) 조작, 이벤트 처리 등의 웹 관련 API를 기본적으로 제공한다.

- Node.js: 파일 시스템, 네트워킹, 스트림, 버퍼, 모듈 시스템 등의 서버 사이드 관련 API를 제공한다.

4. 멀티 스레딩:

- 자바스크립트: 자바스크립트 자체는 싱글 스레드로 동작한다. 그러나 웹 브라우저 환경에서는 Web Workers와 같은 기능으로 멀티 스레딩을 지원한다.

- Node.js: Node.js는 기본적으로 싱글 스레드로 동작하나, cluster 모듈, worker_threads 등을 통해 멀티 스레딩 및 멀티 프로세스를 지원한다.

5. 용도:

- 자바스크립트: 주로 웹 페이지의 인터랙티브한 기능, 애니메이션, 이벤트 처리 등의 클라이언트 사이드 로직 구현에 사용된다.

- Node.js: 백엔드 서비스, API 서버, 웹 서버, 데스크탑 애플리케이션, IoT 장치용 코드 등 다양한 서버 및 네트워크 애플리케이션을 개발하는 데 사용된다.

6. 패키지 관리자:

- 자바스크립트: 웹 브라우저 환경에서는 패키지 관리자가 기본적으로 제공되지 않지만, 다양한 라이브러리를 CDN(Content Delivery Network)을 통해 사용할 수 있다.

- Node.js: NPM(Node Package Manager) 또는 Yarn을 사용하여 수 천 개의 패키지와 라이브러리를 쉽게 설치하고 관리할 수 있다.

7. 모듈 시스템:

- 자바스크립트: ES6부터 import와 export를 통한 모듈 시스템이 표준화됐다.

- Node.js: 초기에는 require()와 module.exports를 통한 CommonJS 모듈 시스템을 사용하였으나, 최근에는 ES6 모듈 시스템도 지원하게 됐다.

요약하면, 자바스크립트는 웹 브라우저에서 클라이언트 사이드 스크립트로 사용되는 반면, Node.js는 서버 사이드나 다른 환경에서 실행되는 JavaScript 런타임이다.

## 동기(Synchronous)와 비동기(Asynchronous)

동기 (Synchronous):
- 정의: 작업이 순차적으로 실행되는 방식을 말한다. 한 작업이 완료되어야 다음 작업이 시작된다.
- 특징:
코드의 실행 순서가 예측 가능하다.
코드가 직관적이고 이해하기 쉽다.
하나의 작업이 오래 걸린다면 그 작업이 완료될 때까지 다른 작업들이 대기해야 하는 문제점이 있다.
특히 I/O 바운드 작업 (예: 디스크 또는 네트워크와 관련된 작업)에서는 효율성이 떨어질 수 있다.
예시: 사용자로부터 입력을 기다리는 상황, 배열의 각 요소를 순차적으로 처리하는 for 루프.

비동기 (Asynchronous):
- 정의: 작업이 독립적으로 실행되는 방식을 말한다. 한 작업이 끝나기를 기다리지 않고 다음 작업을 시작할 수 있다. (병렬적)
- 특징:
코드의 실행 순서가 예측하기 어렵다.
Callback, Promise, Async/Await 등의 패턴 또는 메커니즘을 사용하여 비동기 로직을 관리한다.
I/O 바운드 작업에 효율적이다. 오래 걸리는 작업을 기다리는 동안 다른 작업을 수행할 수 있기 때문에 자원을 더 효율적으로 활용할 수 있다.
예시: AJAX 요청, setTimeout, 파일 읽기/쓰기, 데이터베이스 쿼리 등.

동기와 비동기의 주요 차이점:

- 실행 순서: 동기는 작업 순서가 고정되어 있고 예측 가능하며, 비동기는 작업 순서가 예측하기 어렵다.
- 대기 시간: 동기는 하나의 작업이 완료될 때까지 다른 작업들이 대기해야 하며, 비동기는 그렇지 않다.

비동기 처리는 특히 자바스크립트와 같은 싱글 스레드 환경에서 중요한데, 이는 동시에 여러 작업을 처리할 수 없는 환경에서도 사용자 경험을 높이고, 시스템의 응답성을 유지하기 위해서이다.

## 소켓 (Socket)

소켓은 컴퓨터 네트워킹에서 두 대의 기기가 통신할 수 있게 하는 엔드포인트를 의미한다. 기본적으로 소켓은 IP 주소와 포트 번호의 조합으로 구성되어 있으며, 이를 통해 네트워크 상에서 특정 컴퓨터의 특정 프로세스와 다른 컴퓨터의 특정 프로세스가 서로 데이터를 주고받을 수 있게 된다.

1. 소켓의 유형:
  - 스트림 소켓 (Stream Socket):
TCP(Transmission Control Protocol)를 기반으로 한다.
연결 지향적이며, 데이터의 전송이 신뢰성 있게 보장된다.
대표적인 예로 웹 서버와 클라이언트 간의 통신이 있다.

  - 데이터그램 소켓 (Datagram Socket):
UDP(User Datagram Protocol)를 기반으로 한다.
연결이 없으며, 데이터 전송의 신뢰성을 보장하지 않습니다. 즉, 패킷의 손실이나 순서 변경이 발생할 수 있다.
빠른 전송을 위해 스트리밍 서비스나 게임에서 주로 사용된다.

2. 동작 원리:
- 서버 소켓: 주로 수신 대기 상태로 있으며, 클라이언트로부터의 연결 요청을 기다린다.
- 클라이언트 소켓: 특정 서버의 특정 포트로 연결을 요청하며, 연결이 성립되면 데이터를 주고받을 수 있게 된다.

3. 활용 사례:
- 웹 서버와 클라이언트: HTTP 통신을 할 때 웹 서버와 웹 브라우저(클라이언트) 사이에서 소켓 연결이 사용돤다.
- 채팅 애플리케이션: 실시간 채팅을 구현할 때 소켓 통신을 활용하여 사용자 간의 메시지를 빠르게 교환한다.
- 게임: 멀티플레이어 온라인 게임에서는 소켓을 통해 플레이어 간의 상태 정보를 실시간으로 교환한다.
- 실시간 알림 시스템: 소셜 미디어나 다른 플랫폼에서의 실시간 알림 기능도 소켓을 통해 구현될 수 있다.
4. 웹소켓 (WebSocket):

 웹소켓은 HTTP 기반의 웹에서도 양방향 통신을 가능하게 하는 프로토콜 및 API이다. 전통적인 HTTP는 요청-응답 방식이지만, 웹소켓은 한 번의 핸드쉐이크를 통해 지속적인 연결 상태를 유지하게 된다. 이를 통해 서버와 클라이언트 간에 실시간으로 데이터를 주고받을 수 있게 된다.

요약하면, 소켓은 네트워크 통신에서 데이터를 주고받기 위한 핵심적인 엔드포인트로, 다양한 애플리케이션에서 실시간 또는 지속적인 데이터 교환을 위해 활용된다.

## 단일 스레드 (Single-threaded)

단일 스레드는 컴퓨터 프로세스나 프로그램이 한 번에 하나의 작업만 처리할 수 있는 실행 흐름 구조를 의미한다. 스레드는 프로그램 내에서 실행되는 독립적인 작업 단위를 나타내며, 단일 스레드 환경에서는 한 순간에 오직 하나의 작업만 실행될 수 있다.

1. 특징:
- 순차적 실행: 작업들은 순차적으로, 하나씩 차례대로 처리된다.
- 간단한 구조: 멀티 스레드 환경에서 발생할 수 있는 복잡한 동시성 문제나 경쟁 상태 (race condition) 같은 이슈들이 발생할 가능성이 줄어든다.
- 리소스 절약: 여러 스레드를 관리하는데 필요한 오버헤드나 리소스를 절약할 수 있다.
- I/O 바운드 작업의 제약: CPU 작업과 I/O 작업이 번갈아 나타나는 경우, I/O 작업이 CPU를 대기 상태로 만들 수 있어 전체 성능이 떨어질 수 있다.

2. 예시:
자바스크립트의 Node.js: Node.js는 단일 스레드로 동작하는 런타임 환경이다. 그러나 비동기 I/O를 통해 효율적으로 동작하게 설계되어 있어, I/O 바운드 작업에서 높은 성능을 발휘한다.

3. 단일 스레드 vs 멀티 스레드:
- 단일 스레드: 코드의 실행이 순차적이므로 디버깅이 더 쉽고, 동시성 문제를 피할 수 있다. 그러나 CPU의 여러 코어를 활용하지 못하며, 하나의 작업이 시스템의 전체 응답성을 저하시킬 수 있다.
- 멀티 스레드: 여러 작업을 동시에 처리할 수 있어 성능 향상의 기회가 있다. 그러나 동시성 관련 문제들을 관리하고 해결하는 것이 복잡해질 수 있다.

요약하면, 단일 스레드는 한 번에 하나의 작업만 처리하는 실행 흐름 구조를 가지며, 이로 인해 동시성 관련 문제 없이 코드를 실행할 수 있다. 그러나 특정 작업이 시스템의 전체 응답성에 영향을 미칠 수 있으므로, 효율적인 설계와 구현이 필요하다.

## 원시타입&객체타입

1. 원시 타입 (Primitive Type):

- 정의: JavaScript에서는 기본적으로 제공되는 최소 단위의 데이터 타입을 의미한다.
- 종류:
  - Number: 숫자를 나타내는 타입이다.
  - String: 문자열을 나타내는 타입이다.
  - Boolean: true 또는 false 값만 가질 수 있는 논리 타입이다.
  - Undefined: 값이 할당되지 않은 변수의 타입이다.
  - Null: 의도적으로 값이 없음을 나타내는 타입이다.
  - Symbol: ES6에서 도입된 고유하고 변경 불가능한 데이터 타입이다.
  - BigInt: 큰 정수를 나타내기 위한 타입으로, ES11에서 도입됐다.

- 특징:
원시 타입의 값은 불변(immutable)이다.
원시 타입의 값은 메모리에 고정된 크기로 저장된다.
원시 타입의 변수가 다른 변수에 할당될 때, 값 자체가 복사된다.

2. 객체 타입 (Object Type):

- 정의: 복합 데이터 구조를 나타내는 타입이다. 여러 속성이나 메서드를 포함할 수 있다.
- 종류:
  - Object: 일반적인 객체를 나타내는 타입이다.
  - Array: 순서가 있는 데이터 집합을 나타내는 타입이다.
  - Function: 함수를 나타내는 타입이다.
그 외에도 Date, RegExp, Map, Set 등과 같은 내장 객체 타입들이 있다.

- 특징:
객체는 메모리에 참조 형식으로 저장된다.
객체는 변경 가능(mutable)한다.
객체 타입의 변수가 다른 변수에 할당될 때, 참조(메모리 주소)가 복사된다. 따라서, 두 변수는 동일한 객체를 참조하게 된다.

3. 원시 타입과 객체 타입의 주요 차이점:

- 변경 가능성: 원시 타입은 불변(immutable)하며, 객체 타입은 변경 가능(mutable)하다.
- 메모리 저장 방식: 원시 타입은 값을 직접 저장하고, 객체 타입은 참조를 저장한다.
- 복사와 참조: 원시 타입은 값에 의한 복사(pass by value)가 일어나며, 객체 타입은 참조에 의한 복사(pass by reference)가 발생한다.
- 메서드와 속성: 원시 타입에는 속성과 메서드가 없지만, 객체 타입은 여러 속성과 메서드를 가질 수 있다.

이렇게 원시 타입과 객체 타입은 서로 다른 특징과 용도를 가지며, 이 둘의 차이를 이해하는 것은 프로그래밍에서 중요한 개념 중 하나이다.

##  비동기 함수

1. Callback:
- 정의: 함수를 다른 함수의 인자로 전달하여 특정 동작이 완료된 후에 실행될 수 있도록 하는 함수를 말한다.
- 문제점: 중첩된 콜백(callback hell 또는 pyramid of doom)으로 인해 코드의 가독성이 떨어지고 관리가 어려워진다.
- 예시:
```javascript
Copy code
function getData(callback) {
    // 비동기 작업
    callback(data);
}

getData(function(data) {
    console.log(data);
});
```

2. Promise:
- 정의: 비동기 작업의 최종 완료(또는 실패)와 그 결과 값을 나타내는 객체이다.
- 장점: 콜백 헬 문제를 해결하고, 비동기 작업을 더 깔끔하게 처리할 수 있다.
- 메서드: then() (작업 성공 시), catch() (작업 실패 시), finally() (성공/실패와 관계없이 실행)
- 예시:
```javascript
Copy code
function getData() {
    return new Promise((resolve, reject) => {
        // 비동기 작업
        if (success) {
            resolve(data);
        } else {
            reject(error);
        }
    });
}

getData()
    .then(data => console.log(data))
    .catch(err => console.error(err));
```
3. Async/Await:
- 정의: 비동기 작업을 동기적인 방식처럼 작성할 수 있게 하는 ES7의 특징이다.
- 장점: 코드의 가독성을 크게 향상시키며, try-catch를 사용하여 에러 처리가 더 쉽다.
- 예시:
```javascript
Copy code
async function fetchData() {
    try {
        let response = await getData();  // Promise를 반환하는 함수
        console.log(response);
    } catch (error) {
        console.error(error);
    }
}

fetchData();
```

요약:
- Callback: 비동기 작업 후에 실행할 함수를 인자로 전달하는 방식이다.
- Promise: 비동기 작업의 성공 또는 실패와 그 결과를 나타내는 객체이다.
- Async/Await: 비동기 작업을 동기적 스타일로 작성하게 해주는 문법입니다. 주로 Promise와 함께 사용된다.

## 호이스팅

변수 선언과 초기화의 분리: 변수 선언은 호이스팅되지만, 초기화(값 할당)는 호이스팅되지 않는다.

함수 선언과 함수 표현식의 차이: 함수 선언은 전체가 호이스팅되며, 함수 표현식은 변수 선언만 호이스팅되고 함수 값의 할당은 호이스팅되지 않는다.

예시:
- 변수 호이스팅:
```javascript
Copy code
console.log(myVar);  // undefined
var myVar = 5;
console.log(myVar);  // 5
```
위 코드는 다음과 같이 동작합니다:

```javascript
Copy code
var myVar;
console.log(myVar);  // undefined
myVar = 5;
console.log(myVar);  // 5
```
- 함수 선언의 호이스팅:
```javascript
Copy code
console.log(foo());  // "Hello"

function foo() {
    return "Hello";
}
```

함수 선언은 전체가 호이스팅되므로, 함수를 선언하기 전에 호출해도 문제 없이 동작한다.

- 함수 표현식의 호이스팅:

```javascript
Copy code
console.log(foo);    // undefined
console.log(foo());  // TypeError: foo is not a function

var foo = function() {
    return "Hello";
}
```
변수 foo의 선언만 호이스팅되며, 함수 값의 할당은 호이스팅되지 않는다.

주의점: let과 const를 사용한 변수 선언은 호이스팅되지만, "Temporal Dead Zone"이라는 특성 때문에 선언 전에 접근하려고 하면 ReferenceError가 발생한다.

## 모듈

JavaScript 모듈:

ES6 모듈 (ESM):
ES6에서 도입된 표준 모듈 시스템입니다.
import와 export 키워드를 사용하여 모듈을 가져오거나 내보낼 수 있다.

예시:
```javascript
Copy code
// math.js
export function add(a, b) {
    return a + b;
}

// app.js
import { add } from './math.js';
console.log(add(1, 2));  // 3
```
2. CommonJS (CJS):

Node.js 환경에서 주로 사용되는 모듈 시스템이다.
require와 module.exports를 사용하여 모듈을 가져오거나 내보낼 수 있다.

- 예시:
```javascript
Copy code
// math.js
module.exports = {
    add: function(a, b) {
        return a + b;
    }
};

// app.js
const math = require('./math.js');
console.log(math.add(1, 2));  // 3
```

3. AMD (Asynchronous Module Definition):

비동기적으로 모듈을 로드하는 데 사용되는 모듈 시스템이다.
주로 프론트엔드에서 브라우저 환경에서 사용된다.

4. UMD (Universal Module Definition):

CommonJS와 AMD 스타일의 모듈을 동시에 지원하려는 시도로 만들어진 포맷이다.
여러 환경에서 사용될 수 있도록 설계되었다.


- 모듈의 장점:

1. 재사용성: 동일한 코드를 여러 프로젝트나 여러 위치에서 재사용할 수 있다.
2. 네임스페이스 관리: 모듈은 전역 스코프를 오염시키지 않고, 내부 변수와 함수를 캡슐화한다.
3. 코드의 구조화: 관련된 기능들을 모듈별로 나누어 코드의 구조를 명확하게 만들 수 있다.
4. 의존성 관리: 모듈 시스템을 사용하면 필요한 코드만을 불러와서 사용할 수 있으며, 의존성 관리가 용이해진다.

모듈은 코드를 체계적으로 구성하고 관리하는 데 큰 도움을 주며, 대규모 프로젝트에서는 거의 필수적인 요소이다.

## 데이터 베이스

1. RDBMS (관계형 데이터베이스 관리 시스템)

특징:

- 테이블 기반의 구조.
- 데이터 사이에 관계를 정의하며 외래키, 조인 등의 연산을 사용.
- ACID 속성 (원자성, 일관성, 고립성, 지속성)을 보장.
- SQL (Structured Query Language)을 통한 데이터 조작 및 질의.
- 스키마가 고정적이며 데이터 구조 변경이 복잡할 수 있음.
- 적합한 사용 사례: 트랜잭션 처리, 복잡한 질의, 통합된 데이터 보장이 필요한 시스템.

2. NoSQL (Not Only SQL)

특징:

- 관계형 데이터베이스의 전통적 구조에서 벗어남.
- 확장성이 높아 대량의 데이터와 높은 트래픽을 처리하는 데 적합.
- 고정된 스키마가 없거나 유연하여 데이터 구조 변경이 수월.
- 여러 데이터 모델을 지원: 키-값, 문서, 컬럼, 그래프 등.
- 대부분의 NoSQL 데이터베이스는 ACID 속성보다는 BASE (기본적으로 사용 가능, 부드럽게 상태 변경, 최종적으로 일관성) 모델을 따름.
- 적합한 사용 사례: 대규모 데이터셋, 빠른 읽기/쓰기 작업, 유연한 스키마 요구, 확장성 필요한 애플리케이션.

3. 주요 차이점:

- 데이터 모델: RDBMS는 관계형/테이블 기반, NoSQL은 다양한 데이터 모델을 사용.
- 스키마: RDBMS는 고정된 스키마, NoSQL은 대부분 유연한 스키마.
- 확장성: RDBMS는 수직 확장, NoSQL은 주로 수평 확장.
- 트랜잭션: RDBMS는 ACID를 보장, NoSQL은 BASE 속성을 갖는 경우가 많음.
- 질의 언어: RDBMS는 SQL 사용, NoSQL은 데이터베이스마다 각기 다른 질의 방식을 가질 수 있음.

## 주요 HTTP 상태 코드

1. 1xx (정보 응답)

- 100 Continue: 서버가 요청의 초기 부분을 받았으며 나머지 부분도 계속 보내도 됨을 나타냄.
- 101 Switching Protocols: 서버가 클라이언트의 요청을 따라 프로토콜을 변경함.

2. 2xx (성공 응답)

- 200 OK: 요청이 성공적으로 처리됨.
- 201 Created: 요청이 성공적이며 새로운 리소스가 생성됨.
- 204 No Content: 요청은 성공했지만 응답할 내용이 없음.

3. 3xx (리다이렉션)
- 301 Moved Permanently: 요청한 리소스의 URL이 변경되었음.
- 302 Found: 요청한 리소스의 URL이 일시적으로 변경되었음.
- 304 Not Modified: 클라이언트의 캐시 버전이 여전히 최신임.

4. 4xx (클라이언트 오류)
- 400 Bad Request: 서버가 요청을 파싱하는 데 실패함.
- 401 Unauthorized: 인증에 실패하거나 인증되지 않음.
- 403 Forbidden: 인증과 상관없이 리소스에 대한 접근이 거부됨.
- 404 Not Found: 요청한 리소스를 찾을 수 없음.
- 429 Too Many Requests: 클라이언트가 주어진 시간 동안 너무 많은 요청을 보냄.

5. 5xx (서버 오류)
- 500 Internal Server Error: 서버에 오류가 발생하여 요청을 완료할 수 없음.
- 502 Bad Gateway: 게이트웨이나 프록시 서버에서 잘못된 응답을 받음.
- 503 Service Unavailable: 서버가 일시적으로 서비스를 제공할 수 없음.
- 504 Gateway Timeout: 게이트웨이나 프록시 서버가 시간 내에 응답을 받지 못함.


## 면접후기

오늘 처음으로 면접을 보았다. 태어나서 처음보는 면접(아르바이트 제외) 여서 너무 긴장했다. 알고 있는 것도 다 대답하지 못했다. 심지어 지난 금요일날 복습한 동기와 비동기도 대답하지 못했다. (심지어 호이스팅을 포스팅이라고 들었다...) 면접장에 나오자마자 아차! 했다. 면접장에 나와서 면접에서 받은 질문을 까먹기 전에 빠르게 답을 정리하면서 그동안 면접 준비에 소홀하던 것이 후회됐다. 다 알고 있는 거라고 생각했는데 막상 질문을 받으면 입 안에서 머물고 웅얼대기만 했다. 완벽하게 알지 못한다는 뜻이겠지. 오늘의 뼈아픈 경험을 타산지석 삼아서 열심히 준비하겠다. 나는 신입 개발자이다. 자만하지 말고 밑바닥부터 탄탄하게 공부하자. 파이팅!!!

 그리고 방금 깨달았는데 질문을 받은 내용 전부 내가 예전에 한번 공부하고 깃에 올렸던 것들이다... 공부를 너무 안했구나 내 자신이 부끄러워졌다.