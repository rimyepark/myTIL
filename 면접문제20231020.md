# 면접 반성

 면접에서 나온 질문들을 정리하며 반성하자. 기초부터 더욱 철저하게 공부하자.

 ## javascript와 node.js

1. 정의:

- 자바스크립트 (JavaScript): 웹 브라우저에서 실행되는 스크립트 언어로, 웹 페이지의 동적 기능을 구현하기 위해 주로 사용됩니다. ECMAScript(ES) 기반으로 발전하고 있습니다.

- Node.js: Chrome V8 JavaScript 엔진 위에 구축된 JavaScript 런타임으로, 서버 사이드 애플리케이션을 개발하기 위해 사용됩니다.

2. 실행 환경:

- 자바스크립트: 웹 브라우저 내에서 실행됩니다.
- Node.js: 서버나 컴퓨터의 OS 환경에서 실행됩니다.

3. API와 라이브러리:

- 자바스크립트: DOM(Document Object Model) 조작, 이벤트 처리 등의 웹 관련 API를 기본적으로 제공합니다.

- Node.js: 파일 시스템, 네트워킹, 스트림, 버퍼, 모듈 시스템 등의 서버 사이드 관련 API를 제공합니다.

4. 멀티 스레딩:

- 자바스크립트: 자바스크립트 자체는 싱글 스레드로 동작합니다. 그러나 웹 브라우저 환경에서는 Web Workers와 같은 기능으로 멀티 스레딩을 지원합니다.

- Node.js: Node.js는 기본적으로 싱글 스레드로 동작하나, cluster 모듈, worker_threads 등을 통해 멀티 스레딩 및 멀티 프로세스를 지원합니다.

5. 용도:

- 자바스크립트: 주로 웹 페이지의 인터랙티브한 기능, 애니메이션, 이벤트 처리 등의 클라이언트 사이드 로직 구현에 사용됩니다.

- Node.js: 백엔드 서비스, API 서버, 웹 서버, 데스크탑 애플리케이션, IoT 장치용 코드 등 다양한 서버 및 네트워크 애플리케이션을 개발하는 데 사용됩니다.

6. 패키지 관리자:

- 자바스크립트: 웹 브라우저 환경에서는 패키지 관리자가 기본적으로 제공되지 않지만, 다양한 라이브러리를 CDN(Content Delivery Network)을 통해 사용할 수 있습니다.

- Node.js: NPM(Node Package Manager) 또는 Yarn을 사용하여 수 천 개의 패키지와 라이브러리를 쉽게 설치하고 관리할 수 있습니다.

7. 모듈 시스템:

- 자바스크립트: ES6부터 import와 export를 통한 모듈 시스템이 표준화되었습니다.

- Node.js: 초기에는 require()와 module.exports를 통한 CommonJS 모듈 시스템을 사용하였으나, 최근에는 ES6 모듈 시스템도 지원하게 되었습니다.

요약하면, 자바스크립트는 웹 브라우저에서 클라이언트 사이드 스크립트로 사용되는 반면, Node.js는 서버 사이드나 다른 환경에서 실행되는 JavaScript 런타임입니다.

## 동기(Synchronous)와 비동기(Asynchronous)

동기 (Synchronous):
- 정의: 작업이 순차적으로 실행되는 방식을 말합니다. 한 작업이 완료되어야 다음 작업이 시작됩니다.
- 특징:
코드의 실행 순서가 예측 가능하다.
코드가 직관적이고 이해하기 쉽다.
하나의 작업이 오래 걸린다면 그 작업이 완료될 때까지 다른 작업들이 대기해야 하는 문제점이 있다.
특히 I/O 바운드 작업 (예: 디스크 또는 네트워크와 관련된 작업)에서는 효율성이 떨어질 수 있다.
예시: 사용자로부터 입력을 기다리는 상황, 배열의 각 요소를 순차적으로 처리하는 for 루프.

비동기 (Asynchronous):
- 정의: 작업이 독립적으로 실행되는 방식을 말합니다. 한 작업이 끝나기를 기다리지 않고 다음 작업을 시작할 수 있다.
- 특징:
코드의 실행 순서가 예측하기 어렵다.
Callback, Promise, Async/Await 등의 패턴 또는 메커니즘을 사용하여 비동기 로직을 관리한다.
I/O 바운드 작업에 효율적이다. 오래 걸리는 작업을 기다리는 동안 다른 작업을 수행할 수 있기 때문에 자원을 더 효율적으로 활용할 수 있다.
예시: AJAX 요청, setTimeout, 파일 읽기/쓰기, 데이터베이스 쿼리 등.

동기와 비동기의 주요 차이점:

- 실행 순서: 동기는 작업 순서가 고정되어 있고 예측 가능하며, 비동기는 작업 순서가 예측하기 어렵다.
- 대기 시간: 동기는 하나의 작업이 완료될 때까지 다른 작업들이 대기해야 하며, 비동기는 그렇지 않다.
비동기 처리는 특히 자바스크립트와 같은 싱글 스레드 환경에서 중요한데, 이는 동시에 여러 작업을 처리할 수 없는 환경에서도 사용자 경험을 높이고, 시스템의 응답성을 유지하기 위해서입니다.

## 소켓 (Socket)

소켓은 컴퓨터 네트워킹에서 두 대의 기기가 통신할 수 있게 하는 엔드포인트를 의미합니다. 기본적으로 소켓은 IP 주소와 포트 번호의 조합으로 구성되어 있으며, 이를 통해 네트워크 상에서 특정 컴퓨터의 특정 프로세스와 다른 컴퓨터의 특정 프로세스가 서로 데이터를 주고받을 수 있게 됩니다.

1. 소켓의 유형:
  - 스트림 소켓 (Stream Socket):
TCP(Transmission Control Protocol)를 기반으로 합니다.
연결 지향적이며, 데이터의 전송이 신뢰성 있게 보장됩니다.
대표적인 예로 웹 서버와 클라이언트 간의 통신이 있습니다.

  - 데이터그램 소켓 (Datagram Socket):
UDP(User Datagram Protocol)를 기반으로 합니다.
연결이 없으며, 데이터 전송의 신뢰성을 보장하지 않습니다. 즉, 패킷의 손실이나 순서 변경이 발생할 수 있습니다.
빠른 전송을 위해 스트리밍 서비스나 게임에서 주로 사용됩니다.

2. 동작 원리:
- 서버 소켓: 주로 수신 대기 상태로 있으며, 클라이언트로부터의 연결 요청을 기다립니다.
- 클라이언트 소켓: 특정 서버의 특정 포트로 연결을 요청하며, 연결이 성립되면 데이터를 주고받을 수 있게 됩니다.

3. 활용 사례:
- 웹 서버와 클라이언트: HTTP 통신을 할 때 웹 서버와 웹 브라우저(클라이언트) 사이에서 소켓 연결이 사용됩니다.
- 채팅 애플리케이션: 실시간 채팅을 구현할 때 소켓 통신을 활용하여 사용자 간의 메시지를 빠르게 교환합니다.
- 게임: 멀티플레이어 온라인 게임에서는 소켓을 통해 플레이어 간의 상태 정보를 실시간으로 교환합니다.
- 실시간 알림 시스템: 소셜 미디어나 다른 플랫폼에서의 실시간 알림 기능도 소켓을 통해 구현될 수 있습니다.
4. 웹소켓 (WebSocket):
웹소켓은 HTTP 기반의 웹에서도 양방향 통신을 가능하게 하는 프로토콜 및 API입니다.
전통적인 HTTP는 요청-응답 방식이지만, 웹소켓은 한 번의 핸드쉐이크를 통해 지속적인 연결 상태를 유지하게 됩니다. 이를 통해 서버와 클라이언트 간에 실시간으로 데이터를 주고받을 수 있게 됩니다.

요약하면, 소켓은 네트워크 통신에서 데이터를 주고받기 위한 핵심적인 엔드포인트로, 다양한 애플리케이션에서 실시간 또는 지속적인 데이터 교환을 위해 활용됩니다.

## 단일 스레드 (Single-threaded)

단일 스레드는 컴퓨터 프로세스나 프로그램이 한 번에 하나의 작업만 처리할 수 있는 실행 흐름 구조를 의미합니다. 스레드는 프로그램 내에서 실행되는 독립적인 작업 단위를 나타내며, 단일 스레드 환경에서는 한 순간에 오직 하나의 작업만 실행될 수 있습니다.

1. 특징:
- 순차적 실행: 작업들은 순차적으로, 하나씩 차례대로 처리됩니다.
- 간단한 구조: 멀티 스레드 환경에서 발생할 수 있는 복잡한 동시성 문제나 경쟁 상태 (race condition) 같은 이슈들이 발생할 가능성이 줄어듭니다.
- 리소스 절약: 여러 스레드를 관리하는데 필요한 오버헤드나 리소스를 절약할 수 있습니다.
- I/O 바운드 작업의 제약: CPU 작업과 I/O 작업이 번갈아 나타나는 경우, I/O 작업이 CPU를 대기 상태로 만들 수 있어 전체 성능이 떨어질 수 있습니다.

2. 예시:
자바스크립트의 Node.js: Node.js는 단일 스레드로 동작하는 런타임 환경입니다. 그러나 비동기 I/O를 통해 효율적으로 동작하게 설계되어 있어, I/O 바운드 작업에서 높은 성능을 발휘합니다.

3. 단일 스레드 vs 멀티 스레드:
- 단일 스레드: 코드의 실행이 순차적이므로 디버깅이 더 쉽고, 동시성 문제를 피할 수 있습니다. 그러나 CPU의 여러 코어를 활용하지 못하며, 하나의 작업이 시스템의 전체 응답성을 저하시킬 수 있습니다.
- 멀티 스레드: 여러 작업을 동시에 처리할 수 있어 성능 향상의 기회가 있습니다. 그러나 동시성 관련 문제들을 관리하고 해결하는 것이 복잡해질 수 있습니다.

요약하면, 단일 스레드는 한 번에 하나의 작업만 처리하는 실행 흐름 구조를 가지며, 이로 인해 동시성 관련 문제 없이 코드를 실행할 수 있습니다. 그러나 특정 작업이 시스템의 전체 응답성에 영향을 미칠 수 있으므로, 효율적인 설계와 구현이 필요합니다.

## 원시타입&객체타입

1. 원시 타입 (Primitive Type):

- 정의: JavaScript에서는 기본적으로 제공되는 최소 단위의 데이터 타입을 의미합니다.
- 종류:
  - Number: 숫자를 나타내는 타입입니다.
  - String: 문자열을 나타내는 타입입니다.
  - Boolean: true 또는 false 값만 가질 수 있는 논리 타입입니다.
  - Undefined: 값이 할당되지 않은 변수의 타입입니다.
  - Null: 의도적으로 값이 없음을 나타내는 타입입니다.
  - Symbol: ES6에서 도입된 고유하고 변경 불가능한 데이터 타입입니다.
  - BigInt: 큰 정수를 나타내기 위한 타입으로, ES11에서 도입되었습니다.

- 특징:
원시 타입의 값은 불변(immutable)입니다.
원시 타입의 값은 메모리에 고정된 크기로 저장됩니다.
원시 타입의 변수가 다른 변수에 할당될 때, 값 자체가 복사됩니다.

2. 객체 타입 (Object Type):

- 정의: 복합 데이터 구조를 나타내는 타입입니다. 여러 속성이나 메서드를 포함할 수 있습니다.
- 종류:
  - Object: 일반적인 객체를 나타내는 타입입니다.
  - Array: 순서가 있는 데이터 집합을 나타내는 타입입니다.
  - Function: 함수를 나타내는 타입입니다.
그 외에도 Date, RegExp, Map, Set 등과 같은 내장 객체 타입들이 있습니다.

- 특징:
객체는 메모리에 참조 형식으로 저장됩니다.
객체는 변경 가능(mutable)합니다.
객체 타입의 변수가 다른 변수에 할당될 때, 참조(메모리 주소)가 복사됩니다. 따라서, 두 변수는 동일한 객체를 참조하게 됩니다.

3. 원시 타입과 객체 타입의 주요 차이점:

- 변경 가능성: 원시 타입은 불변(immutable)하며, 객체 타입은 변경 가능(mutable)합니다.
- 메모리 저장 방식: 원시 타입은 값을 직접 저장하고, 객체 타입은 참조를 저장합니다.
- 복사와 참조: 원시 타입은 값에 의한 복사(pass by value)가 일어나며, 객체 타입은 참조에 의한 복사(pass by reference)가 발생합니다.
- 메서드와 속성: 원시 타입에는 속성과 메서드가 없지만, 객체 타입은 여러 속성과 메서드를 가질 수 있습니다.

이렇게 원시 타입과 객체 타입은 서로 다른 특징과 용도를 가지며, 이 둘의 차이를 이해하는 것은 프로그래밍에서 중요한 개념 중 하나입니다.

##  비동기 함수

1. Callback:
- 정의: 함수를 다른 함수의 인자로 전달하여 특정 동작이 완료된 후에 실행될 수 있도록 하는 함수를 말합니다.
- 문제점: 중첩된 콜백(callback hell 또는 pyramid of doom)으로 인해 코드의 가독성이 떨어지고 관리가 어려워집니다.
- 예시:
```javascript
Copy code
function getData(callback) {
    // 비동기 작업
    callback(data);
}

getData(function(data) {
    console.log(data);
});
```

2. Promise:
- 정의: 비동기 작업의 최종 완료(또는 실패)와 그 결과 값을 나타내는 객체입니다.
- 장점: 콜백 헬 문제를 해결하고, 비동기 작업을 더 깔끔하게 처리할 수 있습니다.
- 메서드: then() (작업 성공 시), catch() (작업 실패 시), finally() (성공/실패와 관계없이 실행)
- 예시:
```javascript
Copy code
function getData() {
    return new Promise((resolve, reject) => {
        // 비동기 작업
        if (success) {
            resolve(data);
        } else {
            reject(error);
        }
    });
}

getData()
    .then(data => console.log(data))
    .catch(err => console.error(err));
```
3. Async/Await:
- 정의: 비동기 작업을 동기적인 방식처럼 작성할 수 있게 하는 ES7의 특징입니다.
- 장점: 코드의 가독성을 크게 향상시키며, try-catch를 사용하여 에러 처리가 더 쉽습니다.
- 예시:
```javascript
Copy code
async function fetchData() {
    try {
        let response = await getData();  // Promise를 반환하는 함수
        console.log(response);
    } catch (error) {
        console.error(error);
    }
}

fetchData();
```

요약:
- Callback: 비동기 작업 후에 실행할 함수를 인자로 전달하는 방식입니다.
- Promise: 비동기 작업의 성공 또는 실패와 그 결과를 나타내는 객체입니다.
- Async/Await: 비동기 작업을 동기적 스타일로 작성하게 해주는 문법입니다. 주로 Promise와 함께 사용됩니다.

## 호이스팅

변수 선언과 초기화의 분리: 변수 선언은 호이스팅되지만, 초기화(값 할당)는 호이스팅되지 않습니다.

함수 선언과 함수 표현식의 차이: 함수 선언은 전체가 호이스팅되며, 함수 표현식은 변수 선언만 호이스팅되고 함수 값의 할당은 호이스팅되지 않습니다.

예시:
- 변수 호이스팅:
```javascript
Copy code
console.log(myVar);  // undefined
var myVar = 5;
console.log(myVar);  // 5
```
위 코드는 다음과 같이 동작합니다:

```javascript
Copy code
var myVar;
console.log(myVar);  // undefined
myVar = 5;
console.log(myVar);  // 5
```
- 함수 선언의 호이스팅:
```javascript
Copy code
console.log(foo());  // "Hello"

function foo() {
    return "Hello";
}
```

함수 선언은 전체가 호이스팅되므로, 함수를 선언하기 전에 호출해도 문제 없이 동작합니다.

- 함수 표현식의 호이스팅:

```javascript
Copy code
console.log(foo);    // undefined
console.log(foo());  // TypeError: foo is not a function

var foo = function() {
    return "Hello";
}
```
변수 foo의 선언만 호이스팅되며, 함수 값의 할당은 호이스팅되지 않습니다.

주의점: let과 const를 사용한 변수 선언은 호이스팅되지만, "Temporal Dead Zone"이라는 특성 때문에 선언 전에 접근하려고 하면 ReferenceError가 발생합니다.

## 모듈

JavaScript 모듈:

ES6 모듈 (ESM):
ES6에서 도입된 표준 모듈 시스템입니다.
import와 export 키워드를 사용하여 모듈을 가져오거나 내보낼 수 있습니다.

예시:
```javascript
Copy code
// math.js
export function add(a, b) {
    return a + b;
}

// app.js
import { add } from './math.js';
console.log(add(1, 2));  // 3
```
2. CommonJS (CJS):

Node.js 환경에서 주로 사용되는 모듈 시스템입니다.
require와 module.exports를 사용하여 모듈을 가져오거나 내보낼 수 있습니다.

- 예시:
```javascript
Copy code
// math.js
module.exports = {
    add: function(a, b) {
        return a + b;
    }
};

// app.js
const math = require('./math.js');
console.log(math.add(1, 2));  // 3
```

3. AMD (Asynchronous Module Definition):

비동기적으로 모듈을 로드하는 데 사용되는 모듈 시스템입니다.
주로 프론트엔드에서 브라우저 환경에서 사용됩니다.

4. UMD (Universal Module Definition):

CommonJS와 AMD 스타일의 모듈을 동시에 지원하려는 시도로 만들어진 포맷입니다.
여러 환경에서 사용될 수 있도록 설계되었습니다.


- 모듈의 장점:

1. 재사용성: 동일한 코드를 여러 프로젝트나 여러 위치에서 재사용할 수 있습니다.
2. 네임스페이스 관리: 모듈은 전역 스코프를 오염시키지 않고, 내부 변수와 함수를 캡슐화합니다.
3. 코드의 구조화: 관련된 기능들을 모듈별로 나누어 코드의 구조를 명확하게 만들 수 있습니다.
4. 의존성 관리: 모듈 시스템을 사용하면 필요한 코드만을 불러와서 사용할 수 있으며, 의존성 관리가 용이해집니다.

모듈은 코드를 체계적으로 구성하고 관리하는 데 큰 도움을 주며, 대규모 프로젝트에서는 거의 필수적인 요소입니다.

## 면접후기

오늘 처음으로 면접을 보았다. 태어나서 처음보는 면접(아르바이트 제외) 여서 너무 긴장했다. 알고 있는 것도 다 대답하지 못했다. 심지어 지난 금요일날 복습한 동기와 비동기도 대답하지 못했다. (심지어 호이스팅을 포스팅이라고 들었다...) 면접장에 나오자마자 아차! 했다. 면접장에 나와서 면접에서 받은 질문을 까먹기 전에 빠르게 답을 정리하면서 그동안 면접 준비에 소홀하던 것이 후회됐다. 다 알고 있는 거라고 생각했는데 막상 질문을 받으면 입 안에서 머물고 웅얼대기만 했다. 완벽하게 알지 못한다는 뜻이겠지. 오늘의 뼈아픈 경험을 타산지석 삼아서 열심히 준비하겠다. 나는 신입 개발자이다. 자만하지 말고 밑바닥부터 탄탄하게 공부하자. 파이팅!!!
